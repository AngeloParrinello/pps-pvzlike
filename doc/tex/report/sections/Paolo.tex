\subsection{Paolo Penazzi}
Il mio compito all’interno del progetto, è stato quello di modellare la gerarchia di Entity e Troop,
implementare le piante e l'attore che ne definisce il comportamento, realizzare i proiettili relativi alle piante ed
infine mi sono occupato della generazione dell wave insieme a Parrinello.

\subsubsection{Troop}
Durante la modellazione delle Entity, insieme agli altri membri è stato notato che il comportamento in comune tra le piante e gli zombie poteva essere definito in un concetto di Troop.

Grazie ai \textbf{mixin} mi è stato possibile definire il \texttt{trait Troop} come estensione del \texttt{trait Entity}
a cui viene aggiunta l'abilità di attaccare \texttt{AttackingAbility}.
Questo nuovo concetto di \texttt{Troop} ci ha permesso, in tutto il progetto, di trattare le piante e gli zombie allo stesso modo.

Durante l'analisi del dominio ho notato che le entità subiscono spesso modifiche durante la partita: l'aggiornamento della posizione, quello della vita o quello dello stato.
Ho quindi cercato un modo per rendere naturale questa modifica, che rispettasse però due vincoli:
\begin{itemize}
    \item le entità devono essere immutabili.
    \item l'aggiornamento deve essere fatto in maniera funzionale.
\end{itemize}
Dopo vari tentativi con approcci differenti, la scelta è ricaduta sulla definizione di un metodo per ogni caratteristica da modificare: tale metodo prenderà in input il nuovo valore e restituirà una nuova troop con il campo aggiornato.

Questi metodi sono stati implementati utilizzando il metodo \textbf{copy} di Scala, che permette di fare proprio ciò di cui avevo bisogno.
L'unico difetto di questa soluzione è che il metodo \textit{copy} è disponibile sono nelle \textbf{case class}, quindi tutte le classi che estendono \textit{Troop} dovranno implementare quei metodi.

A questo punto la modifica di una troop può essere effettuata utilizzando la \textbf{notazione infissa}:

\input{code/troop-update.tex}

Questa soluzione è stata poi adottata anche nei Bullet.
Gli stessi principi mi hanno guidato nella creazione di un modo di creare le troop che fosse il più funzionale possibile.
Ho quindi rivisitato il \textbf{pattern builder} per creare troop di qualsiasi tipo: ho creato un \texttt{trait TroopBuilder}
con un unico metodo \textit{build} che ritorna una troop.
Utilizzando le \textbf{given conversion} ho definito un istanza di builder per ogni possibile tipo Troop che si occupa
della creazione di quest'ultima.
Per rendere il builder più coerente con il linguaggio del progetto ho definito un metodo \textit{ofType} che che dato un tipo
di troop chiama utilizza il builder per restituire la nuova entità.

\input{code/troop-builder.tex}

Tutto ciò rende più funzionale la creazione di una troop:

\input{code/troop-creation.tex}

\subsubsection{TroopActor}
Avendo adottato un'architettura ad attori, ogni troop, in fase di creazione, viene associato ad un attore che ne definisce il comportamento.
Il TroopActor ha un solo Behaviour e non è mai proattivo: risponde solamente ai messaggi ricevuti dal GameLoop, rispettando il pattern \textbf{MVC}.

Ad ogni iterazione del GameLoop il TroopActor riceve un messaggio di \textit{Update()} a seguito del quale:
\begin{enumerate}
    \item Aggiorna la propria troop.
    \item Se la troop ha raggiunto la fine della corsia notifica il GameLoop.
    \item Manda la troop aggiornata al GameLoop.
    \item Se c'è un nemico attaccabile, manda a se stesso un messaggio Shoot().
    \item Ricrea il proprio Behaviour con la troop aggiornata.
\end{enumerate}

Nel caso ci sia un'entità da attaccare riceverà il messaggio Shoot(), che si è precedentemente inviato, a seguito del quale:

\begin{enumerate}
    \item Crea il bullet della propria troop.
    \item Crea un BulletActor che controlla il bullet.
    \item Notifica il GameLoop dell'avvenuta creazione con il messaggio BulletSpawned().
\end{enumerate}

Nel caso la troop venga colpita da un bullet, il TroopActor viene notificato dal GameLoop con il messaggio Collision(), a seguito del quale:

\begin{enumerate}
    \item Se la troop viene uccisa, risponde con il messaggio EntityDead()
    \item Se la troop non viene uccisa, risponde con il messaggio EntityUpdated()
\end{enumerate}

Il comportamento del TroopActor viene mostrato nel seguente diagramma:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/troop-actor.png}
    \label{Diagramma di sequenza del Troop Actor.}
\end{figure}

\subsubsection{Plant}
Un'altra parte fondamentale del mio lavoro è stata la modellazione dei vari tipi di piante: sono partito definendo un \texttt{trait Plant} che estende \textit{Troop} e modella il comportamento comune tra le varie piante. Ho poi creato i vari tipi di piante creando delle classi che estendono \textit{Plant.}

A questo punto mi sono accorto che tutte le piante che sparano hanno lo stesso comportamente, l'unica cosa che cambia è il bullet che sparano. Ogni tipo di pianta può essere identificata quindi dal rispettivo bullet.

Ho cercato quindi di migliorare il design, provando a renderlo il più riusabile possibile: per fare ciò ho tentato vari approcci, dall'utilizzo di classi astratte alla delegazione, ognuno dei quali presentava vantaggi e svantaggi. La scelta finale è ricaduta sull'utilizzo di una \textbf{type class} che modella tutte le piante che sparano.

Ho creato la classe \textit{Shooter} che è una type class generica sul tipo di bullet che spara. Questa implementazione è stata possibile grazie all'utilizzo, nel \textit{trait Plant}, di un \textbf{abstract type} \textit{BulletType \textless: Bullet} per definire il tipo di ritorno del metodo \textit{bullet}.

\input{code/plant-shooter.tex}

Per istanziare questa pianta ho definito un metodo ad-hoc, che sotto utilizza il \textit{TroopBuilder} definito in precedenza. È quindi possibile creare shooter nella seguente maniera:

\input{code/shooter-builder.text}

Il diagramma delle piante è il seguente:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/plants.png}
    \label{Diagramma di sequenza del Troop Actor.}
\end{figure}

\subsubsection{Wave}